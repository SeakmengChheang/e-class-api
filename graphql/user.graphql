enum Gender {
    MALE @enum(value: "male")
    FEMALE @enum(value: "female")
    OTHERS @enum(value: "others")
}

type Role {
    id: ID!
    name: String!
    guard_name: String!
    created_at: DateTimeTz!
    updated_at: DateTimeTz!
}

type User {
    id: ID!
    uuid: String
    username: String!
    email: String!
    identity: Identity @hasOne
    roles: [Role!] @hasMany
    learnings: [Classes!] @belongsToMany
    teachings: [Classes!] @hasMany
    created_at: DateTimeTz!
    updated_at: DateTimeTz!
}

type Identity {
    id: ID!
    first_name: String!
    last_name: String!
    gender: Gender!
    photo_url: String
    contact_number: String
    user: User! @belongsTo
    created_at: DateTimeTz!
    updated_at: DateTimeTz!
}

input CreateIdentityBelongsTo {
    connect: ID
    create: CreateIdentityInput
}

input CreateIdentityInput {
    first_name: String!
    last_name: String!
    gender: Gender!
    contact_number: String
    photo: Upload
    user: CreateUserBelongsTo
}

input UpdateIdentityInput {
    user_id: ID! @rules(apply: ["exists:users,id"])
    first_name: String
    last_name: String
    gender: Gender
    contact_number: String
    photo: Upload
}

input CreateUserInput {
    uuid: String!
    username: String!
    email: String!
    password: String!
    identity: CreateIdentityBelongsTo
}

input UpdateUserInput {
    id: ID!
    email: String
    username: String
    uuid: String
    password: String @hash
}

input SyncRolesInput {
    user_id: ID!
    role_ids: [ID!]
}

type Mutation @guard {
    me: User! @auth

    createUser(input: CreateUserInput! @spread): User!
        @create
        @createUserValidation
        @canAccess(requiredRole: "admin")

    updateUser(input: UpdateUserInput! @spread): User!
        @update
        @updateUserValidation
        @canAccess(requiredRole: "admin")

    deleteUser(id: ID! @eq): User! @delete @canAccess(requiredRole: "admin")

    updateIdentity(input: UpdateIdentityInput @spread): User!
        @updateIdentityValidation

    syncRoles(input: SyncRolesInput @spread): User!
        @canAccess(requiredRole: "admin")
}

input OrderByInput {
    orderBy: OrderByClause! @orderBy(columns: ["username"])
}

type Query @guard {
    me: User @auth
    user(id: ID! @eq): User @first @can(ability: "view", find: "id")
    users(orderBy: _ @orderBy(columns: ["username", "uuid", "email"])): [User!]
        @paginate
        @canAccess(requiredRole: "admin")
    usersFindByUsername(username: String!): [User!]
        @paginate
        @canAccess(requiredRole: "admin")
    usersFindByUuid(uuid: String!): [User!]
        @paginate
        @canAccess(requiredRole: "admin")
}
